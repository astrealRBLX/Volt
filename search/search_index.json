{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Volt # Volt is an extremely powerful and lightweight Roblox game framework. Why Volt? # While other game frameworks exist (most notably AGF & Knit), Volt provides a different feature set as well as a different focus. Volt was created around the idea that organization comes before everything else. Many games tend to quickly become disorganized as they get populated with more and more scripts. Volt solves this problem through executables, module scripts Volt can read and assign to the server and client for simple communication between them. Volt also makes giving users the ability to manipulate the control flow of their scripts a priority including in an asynchronous manner. Ready? Lets get started. Warning Volt is not fully documented and some parts may still be missing. If you would like to contribute towards documentation please submit a pull request to the GitHub repository.","title":"Home"},{"location":"#welcome-to-volt","text":"Volt is an extremely powerful and lightweight Roblox game framework.","title":"Welcome to Volt"},{"location":"#why-volt","text":"While other game frameworks exist (most notably AGF & Knit), Volt provides a different feature set as well as a different focus. Volt was created around the idea that organization comes before everything else. Many games tend to quickly become disorganized as they get populated with more and more scripts. Volt solves this problem through executables, module scripts Volt can read and assign to the server and client for simple communication between them. Volt also makes giving users the ability to manipulate the control flow of their scripts a priority including in an asynchronous manner. Ready? Lets get started. Warning Volt is not fully documented and some parts may still be missing. If you would like to contribute towards documentation please submit a pull request to the GitHub repository.","title":"Why Volt?"},{"location":"bridges/","text":"Bridges # Bridges replace the need for RemoteFunctions and RemoteEvents in Volt. They are used to communicate client -> server and server -> client. Creating a Bridge # Bridges are created within executables. Client To Server SomeExecutable.Server local MyExe = { Name = 'MyExe' , Async = false } local function RegisterBridges () MyExe . Volt . RegisterBridge ( 'MyBridge' , function ( player ) print ( 'From client to server!' ) end ) end function MyExe . OnExecute () RegisterBridges () end return MyExe SomeExecutable.Client local MyExe = { Name = 'MyExe' , Async = false } function MyExe . OnExecute () MyExe . Volt . GetBridge ( 'MyBridge' ): Fire () end return MyExe Server To Client SomeExecutable.Server local MyExe = { Name = 'MyExe' , Async = false } local someBridge local function RegisterBridges () someBridge = MyExe . Volt . RegisterBridge ( 'MyBridge' ) end function MyExe . OnExecute () RegisterBridges () --[[ Later in your executable, once you've ensured the client has executed, you can call the :Fire() method on the bridge E.g. someBridge:Fire() ]] end return MyExe SomeExecutable.Client local MyExe = { Name = 'MyExe' , Async = false } function MyExe . OnExecute () MyExe . Volt . GetBridge ( 'MyBridge' ): Hook ( function () print ( 'From server to client!' ) end ) end return MyExe Warning All bridges must be registered on the server. The client does not have access to the RegisterBridge function. Organizing Bridges # Staying organized with your bridges is important. That's why bridges use a similar directory system to Volt's import function. Bridges are placed within Volt in a folder that is generated upon server start called Bridges . When you create a bridge and provide it a name you can actually provide a directory to create for it too. If the directory already exists it will simply use that directory rather than creating another one. --- Bridges ----- SomeBridges -------- MyBridge MyExe . Volt . RegisterBridge ( 'MyExe/SomeBridges/MyBridge' ) Tip Bridges are not bound to their executables. You can get and use a bridge from another executable!","title":"Bridges"},{"location":"bridges/#bridges","text":"Bridges replace the need for RemoteFunctions and RemoteEvents in Volt. They are used to communicate client -> server and server -> client.","title":"Bridges"},{"location":"bridges/#creating-a-bridge","text":"Bridges are created within executables. Client To Server SomeExecutable.Server local MyExe = { Name = 'MyExe' , Async = false } local function RegisterBridges () MyExe . Volt . RegisterBridge ( 'MyBridge' , function ( player ) print ( 'From client to server!' ) end ) end function MyExe . OnExecute () RegisterBridges () end return MyExe SomeExecutable.Client local MyExe = { Name = 'MyExe' , Async = false } function MyExe . OnExecute () MyExe . Volt . GetBridge ( 'MyBridge' ): Fire () end return MyExe Server To Client SomeExecutable.Server local MyExe = { Name = 'MyExe' , Async = false } local someBridge local function RegisterBridges () someBridge = MyExe . Volt . RegisterBridge ( 'MyBridge' ) end function MyExe . OnExecute () RegisterBridges () --[[ Later in your executable, once you've ensured the client has executed, you can call the :Fire() method on the bridge E.g. someBridge:Fire() ]] end return MyExe SomeExecutable.Client local MyExe = { Name = 'MyExe' , Async = false } function MyExe . OnExecute () MyExe . Volt . GetBridge ( 'MyBridge' ): Hook ( function () print ( 'From server to client!' ) end ) end return MyExe Warning All bridges must be registered on the server. The client does not have access to the RegisterBridge function.","title":"Creating a Bridge"},{"location":"bridges/#organizing-bridges","text":"Staying organized with your bridges is important. That's why bridges use a similar directory system to Volt's import function. Bridges are placed within Volt in a folder that is generated upon server start called Bridges . When you create a bridge and provide it a name you can actually provide a directory to create for it too. If the directory already exists it will simply use that directory rather than creating another one. --- Bridges ----- SomeBridges -------- MyBridge MyExe . Volt . RegisterBridge ( 'MyExe/SomeBridges/MyBridge' ) Tip Bridges are not bound to their executables. You can get and use a bridge from another executable!","title":"Organizing Bridges"},{"location":"executables/","text":"Executables # Executables are the most vital part of Volt. They are used to manipulate control flow in an easy and user-friendly manner. They are essentially just module scripts. That's it. The only difference from a normal module script is that Volt knows how to read these module scripts and execute their code in a way that makes your development workflow significantly smoother. Executable Creation # You can store your executables anywhere. It's recommended you create an individual folder to group your executables. Let's say you are creating a Money executable to handle player money. First you would create a folder called Money then within that folder create two module scripts. One for the server and one for the client. To help distinguish them within the explorer you should append .Server or .Client to their names. However, Volt doesn't read your executable names and this is entirely personal preference. Tip Stay organized! Prefer creating a folder within ReplicatedStorage called Exe or Executables to store your executables and prevent clutter. Executable Tables # Now that you have your client and server executables you can start writing code. There is absolutely nothing that distinguishes the executables except for the fact that one will be ran on the server and the other will be ran on the client. Server Example local Money = { Name = 'Money' , Async = false } function Money . OnExecute () print ( 'Server!' ) end return Money Client Example local Money = { Name = 'Money' , Async = false } function Money . OnExecute () print ( 'Client!' ) end return Money These examples are actually identical and run on their respective sides. You may have noticed the Name and Async properties as well as the OnExecute function of the executable table. These are special properties. Special Executable Properties # Properties Type Description Name string Defines the executable name. This is used so executables can communicate with each other. Async boolean Defines whether an executable should be ran on a separate thread when executed. OnExecute function Called when the executable is executed from its respective server or client. Communicating Across Executables # In this example assume we have a Money and Role executable. The Money executable will handle our game's in-game money system for each player. The Role executable will handle our game's in-game role system. Each player will get assigned a role (Civilian, Criminal, or Cop) upon joining. Their money will then be decided based on their role. Role.Server local Role = { Name = 'Role' , Async = false } -- This table is within the Role table so it is public and can be accessed by other executables Role . ValidRoles = { 'Civilian' , 'Criminal' , 'Cop' } -- By not including our players table in the returned Role table we've made it private local players = {} function Role . OnExecute () game : GetService ( 'Players' ). PlayerAdded : Connect ( function ( player ) math.randomseed ( tick ()) local roleChosen = Role . ValidRoles [ math.random ( 1 , # Role . ValidRoles )] players [ player ] = roleChosen -- Await will wait x amount of time (5s in this example) for another executable to execute and then call a function Role . Volt . Server . Await ( 'Money' , 5 , function () -- We know Money has executed so we have access to the AssignMoney function Role . Volt . Server . Money . AssignMoney ( player , roleChosen ) end ) end ) end --[[ Function for getting the role of a player Can be called from other executables! ]] function Role . GetRole ( player ) return players [ player ] end return Role Money.Server local Money = { Name = 'Money' , Async = false } local players = {} function Money . OnExecute () end function Money . AssignMoney ( player , roleChosen ) local Role = Money . Volt . Server . Role if ( roleChosen == Role . ValidRoles [ 1 ]) then -- Civilian players [ player ] = 30 elseif ( roleChosen == Role . ValidRoles [ 2 ]) then -- Criminal players [ player ] = 20 elseif ( roleChosen == Role . ValidRoles [ 3 ]) then -- Cop players [ player ] = 50 end end return Money Main Server Script local Volt = require ( game . ReplicatedStorage . Volt ) local Role = Volt . import ( 'Role.Server' ) local Money = Volt . import ( 'Money.Server' ) Volt . Server . Execute ({ Role , Money }, true ) -- Second argument will override the async property of executables So this is a pretty extensive example. It showcases that Volt injects itself into executables under their return tables. So you can access others by doing: Server MyExecutableTable . Volt . Server . SomeOtherExecutable Client MyExecutableTable . Volt . Client . SomeOtherExecutable Running Executables # Executables should be ran from a server or local script. Smaller games might only have one server script and one local script for each side to handle all their executables. Larger games might need more. Server Script local Volt = require ( game . ReplicatedStorage . Volt ) local SomeExecutable = Volt . import ( 'Executables/SomeExecutable.Server' ) Volt . Server . Execute ({ SomeExecutable }) Local Script local Volt = require ( game . ReplicatedStorage . Volt ) local SomeExecutable = Volt . import ( 'Executables/SomeExecutable.Client' ) Volt . Client . Execute ({ SomeExecutable })","title":"Executables"},{"location":"executables/#executables","text":"Executables are the most vital part of Volt. They are used to manipulate control flow in an easy and user-friendly manner. They are essentially just module scripts. That's it. The only difference from a normal module script is that Volt knows how to read these module scripts and execute their code in a way that makes your development workflow significantly smoother.","title":"Executables"},{"location":"executables/#executable-creation","text":"You can store your executables anywhere. It's recommended you create an individual folder to group your executables. Let's say you are creating a Money executable to handle player money. First you would create a folder called Money then within that folder create two module scripts. One for the server and one for the client. To help distinguish them within the explorer you should append .Server or .Client to their names. However, Volt doesn't read your executable names and this is entirely personal preference. Tip Stay organized! Prefer creating a folder within ReplicatedStorage called Exe or Executables to store your executables and prevent clutter.","title":"Executable Creation"},{"location":"executables/#executable-tables","text":"Now that you have your client and server executables you can start writing code. There is absolutely nothing that distinguishes the executables except for the fact that one will be ran on the server and the other will be ran on the client. Server Example local Money = { Name = 'Money' , Async = false } function Money . OnExecute () print ( 'Server!' ) end return Money Client Example local Money = { Name = 'Money' , Async = false } function Money . OnExecute () print ( 'Client!' ) end return Money These examples are actually identical and run on their respective sides. You may have noticed the Name and Async properties as well as the OnExecute function of the executable table. These are special properties.","title":"Executable Tables"},{"location":"executables/#special-executable-properties","text":"Properties Type Description Name string Defines the executable name. This is used so executables can communicate with each other. Async boolean Defines whether an executable should be ran on a separate thread when executed. OnExecute function Called when the executable is executed from its respective server or client.","title":"Special Executable Properties"},{"location":"executables/#communicating-across-executables","text":"In this example assume we have a Money and Role executable. The Money executable will handle our game's in-game money system for each player. The Role executable will handle our game's in-game role system. Each player will get assigned a role (Civilian, Criminal, or Cop) upon joining. Their money will then be decided based on their role. Role.Server local Role = { Name = 'Role' , Async = false } -- This table is within the Role table so it is public and can be accessed by other executables Role . ValidRoles = { 'Civilian' , 'Criminal' , 'Cop' } -- By not including our players table in the returned Role table we've made it private local players = {} function Role . OnExecute () game : GetService ( 'Players' ). PlayerAdded : Connect ( function ( player ) math.randomseed ( tick ()) local roleChosen = Role . ValidRoles [ math.random ( 1 , # Role . ValidRoles )] players [ player ] = roleChosen -- Await will wait x amount of time (5s in this example) for another executable to execute and then call a function Role . Volt . Server . Await ( 'Money' , 5 , function () -- We know Money has executed so we have access to the AssignMoney function Role . Volt . Server . Money . AssignMoney ( player , roleChosen ) end ) end ) end --[[ Function for getting the role of a player Can be called from other executables! ]] function Role . GetRole ( player ) return players [ player ] end return Role Money.Server local Money = { Name = 'Money' , Async = false } local players = {} function Money . OnExecute () end function Money . AssignMoney ( player , roleChosen ) local Role = Money . Volt . Server . Role if ( roleChosen == Role . ValidRoles [ 1 ]) then -- Civilian players [ player ] = 30 elseif ( roleChosen == Role . ValidRoles [ 2 ]) then -- Criminal players [ player ] = 20 elseif ( roleChosen == Role . ValidRoles [ 3 ]) then -- Cop players [ player ] = 50 end end return Money Main Server Script local Volt = require ( game . ReplicatedStorage . Volt ) local Role = Volt . import ( 'Role.Server' ) local Money = Volt . import ( 'Money.Server' ) Volt . Server . Execute ({ Role , Money }, true ) -- Second argument will override the async property of executables So this is a pretty extensive example. It showcases that Volt injects itself into executables under their return tables. So you can access others by doing: Server MyExecutableTable . Volt . Server . SomeOtherExecutable Client MyExecutableTable . Volt . Client . SomeOtherExecutable","title":"Communicating Across Executables"},{"location":"executables/#running-executables","text":"Executables should be ran from a server or local script. Smaller games might only have one server script and one local script for each side to handle all their executables. Larger games might need more. Server Script local Volt = require ( game . ReplicatedStorage . Volt ) local SomeExecutable = Volt . import ( 'Executables/SomeExecutable.Server' ) Volt . Server . Execute ({ SomeExecutable }) Local Script local Volt = require ( game . ReplicatedStorage . Volt ) local SomeExecutable = Volt . import ( 'Executables/SomeExecutable.Client' ) Volt . Client . Execute ({ SomeExecutable })","title":"Running Executables"},{"location":"start/","text":"Getting Started # Starting with Volt is straightforward, easy, and user-friendly. Installation # Roblox Model Get the Roblox Volt model here . Use the Toolbox to place it under ReplicatedStorage. That's it! With Rojo Download the ZIP from the latest release here . Unzip it and drag Volt into your Rojo project's src directory. Make sure to add Volt's $path under ReplicatedStorage in your default.project.json Configuration # Volt's config is compact and doesn't have anything that needs touching. Insure that VoltPath is set to the path of your Volt module. You can mess with the root key if you would like your imports to begin somewhere else. For example, you may have a folder within ReplicatedStorage called Modules. If you wanted your import strings to start from within there you would set root to game : GetService ( 'ReplicatedStorage' ). Modules . Note Assume the root path remains unchanged from its default ReplicatedStorage value in the rest of the documentation examples. Imports # Volt provides users a useful import function. There's no longer a need to use Roblox's global require() function. Import is specifically tailored to meet the needs of Volt and you should prefer it whenever possible (which is almost always). Basic Importing # local Volt = require ( game . ReplicatedStorage . Volt ) local SomeModule = Volt . import ( 'MyModule' ) You can also provide a directory to start you import in rather than Volt using the root directory. local SomeModule = Volt . import ( 'MyModule' , script . Parent . Parent ) Volt Directory System # Volt uses a powerful and intuitive directory system. This system strays away from Roblox's dot notation and chained :FindFirstChild() methods which can be repetitive, tedious to type, and very very long. Rather, Volt uses a directory system similar to your computer's file system. Have a module deep within your root path and need to import it? Let's compare using Volt versus using the raw Roblox API. Volt Volt . import ( 'Some/Directory/MyModule' ) Roblox require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'Some' ): FindFirstChild ( 'Directory' ): FindFirstChild ( 'MyModule' )) There's a pretty major difference here in terms of length and readability. On top of this imports have a priority system. Priority Order # When importing something Volt prioritizes files in certain directories first. Import's optional 2nd argument Root directory Volt Special Import Properties # When Volt attempts to import a module it checks for a few things. First it will determine if the module is returning a table. If all the module returns is a value or a function or something that isn't a table then Volt will directly return that. Otherwise if the module is a table then Volt will check for an importable key in the returned table. If this is set to false Volt will spit out an error stating that the module is not importable. This is primarily used internally. Finally, Volt will check for an OnImport function in the returned table. If one exists it will call the function. This is useful if you want your modules to have some special behavior when imported. Here's an example of a module using these special properties. local MyModule = { importable = true } function MyModule . OnImport () print ( 'Imported!' ) end return MyModule Note These special properties are all entirely optional and are simply meant to add an extra layer of functionality to modules.","title":"Getting Started"},{"location":"start/#getting-started","text":"Starting with Volt is straightforward, easy, and user-friendly.","title":"Getting Started"},{"location":"start/#installation","text":"Roblox Model Get the Roblox Volt model here . Use the Toolbox to place it under ReplicatedStorage. That's it! With Rojo Download the ZIP from the latest release here . Unzip it and drag Volt into your Rojo project's src directory. Make sure to add Volt's $path under ReplicatedStorage in your default.project.json","title":"Installation"},{"location":"start/#configuration","text":"Volt's config is compact and doesn't have anything that needs touching. Insure that VoltPath is set to the path of your Volt module. You can mess with the root key if you would like your imports to begin somewhere else. For example, you may have a folder within ReplicatedStorage called Modules. If you wanted your import strings to start from within there you would set root to game : GetService ( 'ReplicatedStorage' ). Modules . Note Assume the root path remains unchanged from its default ReplicatedStorage value in the rest of the documentation examples.","title":"Configuration"},{"location":"start/#imports","text":"Volt provides users a useful import function. There's no longer a need to use Roblox's global require() function. Import is specifically tailored to meet the needs of Volt and you should prefer it whenever possible (which is almost always).","title":"Imports"},{"location":"start/#basic-importing","text":"local Volt = require ( game . ReplicatedStorage . Volt ) local SomeModule = Volt . import ( 'MyModule' ) You can also provide a directory to start you import in rather than Volt using the root directory. local SomeModule = Volt . import ( 'MyModule' , script . Parent . Parent )","title":"Basic Importing"},{"location":"start/#volt-directory-system","text":"Volt uses a powerful and intuitive directory system. This system strays away from Roblox's dot notation and chained :FindFirstChild() methods which can be repetitive, tedious to type, and very very long. Rather, Volt uses a directory system similar to your computer's file system. Have a module deep within your root path and need to import it? Let's compare using Volt versus using the raw Roblox API. Volt Volt . import ( 'Some/Directory/MyModule' ) Roblox require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'Some' ): FindFirstChild ( 'Directory' ): FindFirstChild ( 'MyModule' )) There's a pretty major difference here in terms of length and readability. On top of this imports have a priority system.","title":"Volt Directory System"},{"location":"start/#priority-order","text":"When importing something Volt prioritizes files in certain directories first. Import's optional 2nd argument Root directory Volt","title":"Priority Order"},{"location":"start/#special-import-properties","text":"When Volt attempts to import a module it checks for a few things. First it will determine if the module is returning a table. If all the module returns is a value or a function or something that isn't a table then Volt will directly return that. Otherwise if the module is a table then Volt will check for an importable key in the returned table. If this is set to false Volt will spit out an error stating that the module is not importable. This is primarily used internally. Finally, Volt will check for an OnImport function in the returned table. If one exists it will call the function. This is useful if you want your modules to have some special behavior when imported. Here's an example of a module using these special properties. local MyModule = { importable = true } function MyModule . OnImport () print ( 'Imported!' ) end return MyModule Note These special properties are all entirely optional and are simply meant to add an extra layer of functionality to modules.","title":"Special Import Properties"},{"location":"api/bridges/","text":"Bridge API # Server # any Bridge:Fire(Player client [, ...]) # Fire a bridge on a client. Server -> Client void Bridge:Hook(function callback) # Hook a bridge to a callback. Client -> Server Client # any Bridge:Fire([...]) # Fire a bridge on the server. Client -> Server void Bridge:Hook(function callback) # Hook a bridge to a callback. Server -> Client","title":"Bridges"},{"location":"api/bridges/#bridge-api","text":"","title":"Bridge API"},{"location":"api/bridges/#server","text":"","title":"Server"},{"location":"api/bridges/#any-bridgefireplayer-client","text":"Fire a bridge on a client. Server -> Client","title":"any Bridge:Fire(Player client [, ...])"},{"location":"api/bridges/#void-bridgehookfunction-callback","text":"Hook a bridge to a callback. Client -> Server","title":"void Bridge:Hook(function callback)"},{"location":"api/bridges/#client","text":"","title":"Client"},{"location":"api/bridges/#any-bridgefire","text":"Fire a bridge on the server. Client -> Server","title":"any Bridge:Fire([...])"},{"location":"api/bridges/#void-bridgehookfunction-callback_1","text":"Hook a bridge to a callback. Server -> Client","title":"void Bridge:Hook(function callback)"},{"location":"api/executables/","text":"Executable API # Volt # Volt injects directly into an executable directly before execution under MyExecutableTable.Volt . Module|Executable|Library Volt.import(Path importPath [, Instance startDirectory]) # For more information view Imports Server # Executables have access to the same functions as Volt's Server . The Server injects into an executable directly before execution under MyExecutableTable.Volt.Server . Bridge Server.RegisterBridge(Path bridgePath [, function callback]) # Register a new bridge to go client to server or server to client. View the Bridge API to learn more. Client # Executables have access to the same functions as Volt's Client . The Client injects into an executable directly before execution under MyExecutableTable.Volt.Client . Bridge Client.GetBridge(Path bridgePath) # Get an existing bridge. View the Bridge API to learn more.","title":"Executables"},{"location":"api/executables/#executable-api","text":"","title":"Executable API"},{"location":"api/executables/#volt","text":"Volt injects directly into an executable directly before execution under MyExecutableTable.Volt .","title":"Volt"},{"location":"api/executables/#moduleexecutablelibrary-voltimportpath-importpath-instance-startdirectory","text":"For more information view Imports","title":"Module|Executable|Library Volt.import(Path importPath [, Instance startDirectory])"},{"location":"api/executables/#server","text":"Executables have access to the same functions as Volt's Server . The Server injects into an executable directly before execution under MyExecutableTable.Volt.Server .","title":"Server"},{"location":"api/executables/#bridge-serverregisterbridgepath-bridgepath-function-callback","text":"Register a new bridge to go client to server or server to client. View the Bridge API to learn more.","title":"Bridge Server.RegisterBridge(Path bridgePath [, function callback])"},{"location":"api/executables/#client","text":"Executables have access to the same functions as Volt's Client . The Client injects into an executable directly before execution under MyExecutableTable.Volt.Client .","title":"Client"},{"location":"api/executables/#bridge-clientgetbridgepath-bridgepath","text":"Get an existing bridge. View the Bridge API to learn more.","title":"Bridge Client.GetBridge(Path bridgePath)"},{"location":"api/volt/","text":"Volt API # Module|Executable|Library Volt.import(Path importPath [, Instance startDirectory]) # For more information view Imports Server # void Server.Execute(table executables [, bool isAsync]) # Execute a table of executables and determine whether to execute them each in a separate thread or not. The isAsync argument overrides the Async property of executables if isAsync is set to true. void Await(string executableName [, number timeout] [, function callback]) # Execute a function callback after an executable has completed execution. Keep in mind if the executable you await is running on a separate thread there will be nothing to await. When this function is called it will be executed in a separate thread and will not yield the current thread. Executable Server.ExecutableName # You can reference an executable via dot notation. Keep in mind the executable will inject itself only after it has completed execution. Client # void Client.Execute(table executables, [, bool isAsync]) # Reference void Await(string executableName [, number timeout] [, function callback]) # Reference Executable Client.ExecutableName # Reference Libraries # Library Libraries.LibraryName # You can directly reference a library through Volt.Libraries . Please be aware this has the potential to cause unexpected functionality, prefer Volt.import('Libraries/...') . Config # Contains the returned table from Volt.Config .","title":"Volt"},{"location":"api/volt/#volt-api","text":"","title":"Volt API"},{"location":"api/volt/#moduleexecutablelibrary-voltimportpath-importpath-instance-startdirectory","text":"For more information view Imports","title":"Module|Executable|Library Volt.import(Path importPath [, Instance startDirectory])"},{"location":"api/volt/#server","text":"","title":"Server"},{"location":"api/volt/#void-serverexecutetable-executables-bool-isasync","text":"Execute a table of executables and determine whether to execute them each in a separate thread or not. The isAsync argument overrides the Async property of executables if isAsync is set to true.","title":"void Server.Execute(table executables [, bool isAsync])"},{"location":"api/volt/#void-awaitstring-executablename-number-timeout-function-callback","text":"Execute a function callback after an executable has completed execution. Keep in mind if the executable you await is running on a separate thread there will be nothing to await. When this function is called it will be executed in a separate thread and will not yield the current thread.","title":"void Await(string executableName [, number timeout] [, function callback])"},{"location":"api/volt/#executable-serverexecutablename","text":"You can reference an executable via dot notation. Keep in mind the executable will inject itself only after it has completed execution.","title":"Executable Server.ExecutableName"},{"location":"api/volt/#client","text":"","title":"Client"},{"location":"api/volt/#void-clientexecutetable-executables-bool-isasync","text":"Reference","title":"void Client.Execute(table executables, [, bool isAsync])"},{"location":"api/volt/#void-awaitstring-executablename-number-timeout-function-callback_1","text":"Reference","title":"void Await(string executableName [, number timeout] [, function callback])"},{"location":"api/volt/#executable-clientexecutablename","text":"Reference","title":"Executable Client.ExecutableName"},{"location":"api/volt/#libraries","text":"","title":"Libraries"},{"location":"api/volt/#library-librarieslibraryname","text":"You can directly reference a library through Volt.Libraries . Please be aware this has the potential to cause unexpected functionality, prefer Volt.import('Libraries/...') .","title":"Library Libraries.LibraryName"},{"location":"api/volt/#config","text":"Contains the returned table from Volt.Config .","title":"Config"},{"location":"libs/","text":"Libraries # Volt comes packaged with a few libraries that are popular and you may find useful. You can also create your own libraries. Libraries vs Modules # Think of libraries as modules with a bit more functionality. They support the same special properties normal modules do when imported but have even more power. Libraries should go within the Libraries folder of Volt. All modules within this folder are deep loaded using : GetDescendants () . Libraries also have access to each other. Let's say I have a library that uses the Volt's provided Array library. Volt will inject itself into the return table. local MyLibrary = {} local Array -- Initially undefined function MyLibrary . constructor () Array = MyLibrary . Volt . Libraries . Array -- Access injected library end return MyLibrary Info Libraries are required() at server start unlike other modules which are required() when they are imported. Constructors # Libraries have optional constructors. The way you add a constructor to a library is by simply adding a function called constructor to the return table. local MyLibrary = {} function MyLibrary . constructor () print ( 'Constructed!' ) end return MyLibrary Importing Libraries # local SomeLibrary = Volt . import ( 'Libraries/SomeLibrary' )","title":"Overview"},{"location":"libs/#libraries","text":"Volt comes packaged with a few libraries that are popular and you may find useful. You can also create your own libraries.","title":"Libraries"},{"location":"libs/#libraries-vs-modules","text":"Think of libraries as modules with a bit more functionality. They support the same special properties normal modules do when imported but have even more power. Libraries should go within the Libraries folder of Volt. All modules within this folder are deep loaded using : GetDescendants () . Libraries also have access to each other. Let's say I have a library that uses the Volt's provided Array library. Volt will inject itself into the return table. local MyLibrary = {} local Array -- Initially undefined function MyLibrary . constructor () Array = MyLibrary . Volt . Libraries . Array -- Access injected library end return MyLibrary Info Libraries are required() at server start unlike other modules which are required() when they are imported.","title":"Libraries vs Modules"},{"location":"libs/#constructors","text":"Libraries have optional constructors. The way you add a constructor to a library is by simply adding a function called constructor to the return table. local MyLibrary = {} function MyLibrary . constructor () print ( 'Constructed!' ) end return MyLibrary","title":"Constructors"},{"location":"libs/#importing-libraries","text":"local SomeLibrary = Volt . import ( 'Libraries/SomeLibrary' )","title":"Importing Libraries"},{"location":"libs/component/","text":"Component # Component is a library made specifically for Volt. You can use Component to create components which are essentially just containers of instances. These instances can have events binded to them in bulk. Examples # local Volt = require ( game . ReplicatedStorage . Volt ) local Component = Volt . import ( 'Libraries/Instances/Component' ) local myComponent = Component . new ( 'KillParts' ) myComponent : Assign ({ workspace . KillPart1 , workspace . KillPart2 }): Connect ( 'Touched' , function ( self , hit ) -- self is the instance the event was fired on print ( self . Name , 'was touched by' , hit . Name ) end ) API # Component Component.new(string name) # Create a new component Component Component.Get(string name) # Get an existing component by name Component Component:Assign({Instance} instances) # Assign instances to a component Component Component:Connect(string event, function callback) # Bulk connect an event & callback to a component's instances Component Component:Clean() # Clean up a component's connections void Component:Destroy() # Fully destroy & clean a component","title":"Component"},{"location":"libs/component/#component","text":"Component is a library made specifically for Volt. You can use Component to create components which are essentially just containers of instances. These instances can have events binded to them in bulk.","title":"Component"},{"location":"libs/component/#examples","text":"local Volt = require ( game . ReplicatedStorage . Volt ) local Component = Volt . import ( 'Libraries/Instances/Component' ) local myComponent = Component . new ( 'KillParts' ) myComponent : Assign ({ workspace . KillPart1 , workspace . KillPart2 }): Connect ( 'Touched' , function ( self , hit ) -- self is the instance the event was fired on print ( self . Name , 'was touched by' , hit . Name ) end )","title":"Examples"},{"location":"libs/component/#api","text":"","title":"API"},{"location":"libs/component/#component-componentnewstring-name","text":"Create a new component","title":"Component Component.new(string name)"},{"location":"libs/component/#component-componentgetstring-name","text":"Get an existing component by name","title":"Component Component.Get(string name)"},{"location":"libs/component/#component-componentassigninstance-instances","text":"Assign instances to a component","title":"Component Component:Assign({Instance} instances)"},{"location":"libs/component/#component-componentconnectstring-event-function-callback","text":"Bulk connect an event & callback to a component's instances","title":"Component Component:Connect(string event, function callback)"},{"location":"libs/component/#component-componentclean","text":"Clean up a component's connections","title":"Component Component:Clean()"},{"location":"libs/component/#void-componentdestroy","text":"Fully destroy & clean a component","title":"void Component:Destroy()"},{"location":"libs/instancebuilder/","text":"InstanceBuilder # InstanceBuilder is a library created specifically for Volt. It allows you to use method chaining to quickly create instances. Settings # enabled - Is InstanceBuilder enabled? Example # local Volt = require ( game . ReplicatedStorage . Volt ) Volt . import ( 'Libraries/Instances/InstanceBuilder' ) local myPart = Instance . new ( 'Part' ) . Name ( 'My Part!' ) . Color ( Color3 . fromRGB ( 255 , 0 , 0 )) . Parent ( workspace ) . Build () -- .Build() returns the Roblox instance itself Instance . new ( 'Part' ) . Name ( 'Anonymous Part!' ) . Parent ( workspace ) Tip There is no need to set imported InstanceBuilder to a variable. It will override your script environment's default Instance class.","title":"InstanceBuilder"},{"location":"libs/instancebuilder/#instancebuilder","text":"InstanceBuilder is a library created specifically for Volt. It allows you to use method chaining to quickly create instances.","title":"InstanceBuilder"},{"location":"libs/instancebuilder/#settings","text":"enabled - Is InstanceBuilder enabled?","title":"Settings"},{"location":"libs/instancebuilder/#example","text":"local Volt = require ( game . ReplicatedStorage . Volt ) Volt . import ( 'Libraries/Instances/InstanceBuilder' ) local myPart = Instance . new ( 'Part' ) . Name ( 'My Part!' ) . Color ( Color3 . fromRGB ( 255 , 0 , 0 )) . Parent ( workspace ) . Build () -- .Build() returns the Roblox instance itself Instance . new ( 'Part' ) . Name ( 'Anonymous Part!' ) . Parent ( workspace ) Tip There is no need to set imported InstanceBuilder to a variable. It will override your script environment's default Instance class.","title":"Example"},{"location":"libs/promise/","text":"Promise # Promise was created by evaera and used by Volt. The GitHub for it can be found here . Documentation #","title":"Promise"},{"location":"libs/promise/#promise","text":"Promise was created by evaera and used by Volt. The GitHub for it can be found here .","title":"Promise"},{"location":"libs/promise/#documentation","text":"","title":"Documentation"},{"location":"libs/spring/","text":"Spring # Spring is a library by fractality included in RoStrap that was ported over to Volt. It can be used to create critically damped springs. API # Spring Spring.new(double damp, double freq, vector pos) # Create a new spring. void Spring:SetGoal(vector goal) # Set a spring's goal. void Spring:SetFrequency(double freq) # Set a spring's frequency. void Spring:SetDampingRatio(double damp) # Set a spring's damping ratio. vector Spring:GetPosition() # Get a spring's position. vector Spring:GetVelocity() # Get a spring's velocity. vector Spring:Update(double dt) # Call the spring to update by passing in delta time. Recommended use in a Roblox provided loop such as RenderStepped . void Spring:Reset(vector state) # Reset a spring to a provided state.","title":"Spring"},{"location":"libs/spring/#spring","text":"Spring is a library by fractality included in RoStrap that was ported over to Volt. It can be used to create critically damped springs.","title":"Spring"},{"location":"libs/spring/#api","text":"","title":"API"},{"location":"libs/spring/#spring-springnewdouble-damp-double-freq-vector-pos","text":"Create a new spring.","title":"Spring Spring.new(double damp, double freq, vector pos)"},{"location":"libs/spring/#void-springsetgoalvector-goal","text":"Set a spring's goal.","title":"void Spring:SetGoal(vector goal)"},{"location":"libs/spring/#void-springsetfrequencydouble-freq","text":"Set a spring's frequency.","title":"void Spring:SetFrequency(double freq)"},{"location":"libs/spring/#void-springsetdampingratiodouble-damp","text":"Set a spring's damping ratio.","title":"void Spring:SetDampingRatio(double damp)"},{"location":"libs/spring/#vector-springgetposition","text":"Get a spring's position.","title":"vector Spring:GetPosition()"},{"location":"libs/spring/#vector-springgetvelocity","text":"Get a spring's velocity.","title":"vector Spring:GetVelocity()"},{"location":"libs/spring/#vector-springupdatedouble-dt","text":"Call the spring to update by passing in delta time. Recommended use in a Roblox provided loop such as RenderStepped .","title":"vector Spring:Update(double dt)"},{"location":"libs/spring/#void-springresetvector-state","text":"Reset a spring to a provided state.","title":"void Spring:Reset(vector state)"},{"location":"libs/table/","text":"Table # Table is a useful Lua table manipulation library. Examples # local Volt = require ( game . ReplicatedStorage . Volt ) local Table = Volt . import ( 'Libraries/Utilities/Table' ) local myTable = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' } print ( Table . Select ( myTable , 2 , 5 )) --> Outputs: {'b', 'c', 'd', 'e'} print ( Table . Split ( myTable , 3 )) --> Outputs: {'a', 'b', 'c'}, {'d', 'e', 'f'} print ( Table . Wrap ( myTable , 2 )) --> Outputs: {'e', 'f', 'a', 'b', 'c', 'd'} print ( Table . Shift ( myTable , - 5 )) --> Outputs: {[-4] = 'a', [-3] = 'b', [-2] = 'c', [-1] = 'd', [0] = 'e', [1] = 'f'} print ( Table . Extend ( myTable , { 'g' , 'h' , 'i' })) --> Outputs: {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'} print ( Table . Clean ( myTable , 'a' )) --> Outputs: {'b', 'c', 'd', 'e', 'f'} print ( Table . Copy ( myTable )) --> Outputs: {'a', 'b', 'c', 'd', 'e', 'f'} print ( Table . Fill ( myTable , 'filler' , 2 , 5 )) --> Outputs: {'a', 'filler', 'filler', 'filler', 'filler', 'f'} print ( Table . CopyWithin ( myTable , 1 , 3 , 5 )) --> Outputs: {'c', 'd', 'e', 'd', 'e', 'f'} print ( Table . Filter ( myTable , function ( v ) return v == 'c' or v == 'f' end )) --> Outputs: {'c', 'f'} print ( Table . Flatten ( myTable , { 1 , 2 , 3 , { 4 , 5 , 6 , { 7 , 8 , { 9 , 10 }}}})) --> Outputs: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} local readOnly = Table . ReadOnly ( myTable ) readOnly . abc = 'Hello world!' --> Errors: Attempt to set a value on a read-only table.","title":"Table"},{"location":"libs/table/#table","text":"Table is a useful Lua table manipulation library.","title":"Table"},{"location":"libs/table/#examples","text":"local Volt = require ( game . ReplicatedStorage . Volt ) local Table = Volt . import ( 'Libraries/Utilities/Table' ) local myTable = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' } print ( Table . Select ( myTable , 2 , 5 )) --> Outputs: {'b', 'c', 'd', 'e'} print ( Table . Split ( myTable , 3 )) --> Outputs: {'a', 'b', 'c'}, {'d', 'e', 'f'} print ( Table . Wrap ( myTable , 2 )) --> Outputs: {'e', 'f', 'a', 'b', 'c', 'd'} print ( Table . Shift ( myTable , - 5 )) --> Outputs: {[-4] = 'a', [-3] = 'b', [-2] = 'c', [-1] = 'd', [0] = 'e', [1] = 'f'} print ( Table . Extend ( myTable , { 'g' , 'h' , 'i' })) --> Outputs: {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'} print ( Table . Clean ( myTable , 'a' )) --> Outputs: {'b', 'c', 'd', 'e', 'f'} print ( Table . Copy ( myTable )) --> Outputs: {'a', 'b', 'c', 'd', 'e', 'f'} print ( Table . Fill ( myTable , 'filler' , 2 , 5 )) --> Outputs: {'a', 'filler', 'filler', 'filler', 'filler', 'f'} print ( Table . CopyWithin ( myTable , 1 , 3 , 5 )) --> Outputs: {'c', 'd', 'e', 'd', 'e', 'f'} print ( Table . Filter ( myTable , function ( v ) return v == 'c' or v == 'f' end )) --> Outputs: {'c', 'f'} print ( Table . Flatten ( myTable , { 1 , 2 , 3 , { 4 , 5 , 6 , { 7 , 8 , { 9 , 10 }}}})) --> Outputs: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} local readOnly = Table . ReadOnly ( myTable ) readOnly . abc = 'Hello world!' --> Errors: Attempt to set a value on a read-only table.","title":"Examples"},{"location":"libs/tween/","text":"Tween # Tween is a great library as an alternative to Roblox's TweenService.","title":"Tween"},{"location":"libs/tween/#tween","text":"Tween is a great library as an alternative to Roblox's TweenService.","title":"Tween"},{"location":"libs/wait/","text":"Wait # Wait is a library originally created by CloneTrooper1019 that was ported over to Volt. It is a more optimized version of the global Roblox wait() function. Settings # enabled - Is Wait enabled? warnings - Should Wait warn you about the dangers of wait()? Example # local Volt = require ( game . ReplicatedStorage . Volt ) Volt . import ( 'Libraries/Utilities/Wait' ) wait () --> Outputs a warning since warnings are enabled by default Tip There is no need to set imported Wait to a variable. It will override your script environment's default wait() function.","title":"Wait"},{"location":"libs/wait/#wait","text":"Wait is a library originally created by CloneTrooper1019 that was ported over to Volt. It is a more optimized version of the global Roblox wait() function.","title":"Wait"},{"location":"libs/wait/#settings","text":"enabled - Is Wait enabled? warnings - Should Wait warn you about the dangers of wait()?","title":"Settings"},{"location":"libs/wait/#example","text":"local Volt = require ( game . ReplicatedStorage . Volt ) Volt . import ( 'Libraries/Utilities/Wait' ) wait () --> Outputs a warning since warnings are enabled by default Tip There is no need to set imported Wait to a variable. It will override your script environment's default wait() function.","title":"Example"}]}